# EIP-8004a: Bidirectional Trust Extension - Technical Specification

**Week 5 Day 2:** Formal Specification - Part 2 (Contract Interface, State Transitions, Rationale, Security)
**Date:** October 31, 2025
**Status:** Draft for Review

---

## Specification (Continued)

### Contract Interface

#### New Methods (Bidirectional Extension)

**1. rateClient**

```solidity
/**
 * @notice Allows a server agent to rate a client's quality
 * @param agentClientId The client agent ID to rate
 * @param rating The rating score (0-100, where 0=poor, 100=excellent)
 * @dev Caller must be a registered agent (resolved via IdentityRegistry)
 * @dev Client must exist in IdentityRegistry
 * @dev Rating is stored permanently (immutable)
 * @dev Emits ClientRated event
 */
function rateClient(uint256 agentClientId, uint8 rating) external;
```

**Parameters:**
- `agentClientId` (uint256): The agent ID of the client being rated
- `rating` (uint8): Quality score from 0 to 100
  - 0-30: Poor (payment issues, communication problems, dishonest)
  - 31-60: Below average (some issues, proceed with caution)
  - 61-80: Good (reliable, minor issues)
  - 81-100: Excellent (prompt, clear, honest)

**Requirements:**
- Caller must be registered in IdentityRegistry
- `agentClientId` must exist in IdentityRegistry
- `rating` must be ≤ 100
- No self-rating prevention (trust servers to rate honestly; V2 enhancement)

**Events Emitted:**
```solidity
event ClientRated(
    uint256 indexed clientId,
    uint256 indexed serverId,
    uint8 rating
);
```

**Gas Cost:** ~21,557 gas (measured on Avalanche Fuji, Week 2 average)

**Storage:**
```solidity
// Rating stored at: _clientRatings[clientId][serverId] = rating
// Existence flag: _hasClientRating[clientId][serverId] = true
```

---

**2. rateValidator**

```solidity
/**
 * @notice Allows a server agent to rate a validator's quality
 * @param agentValidatorId The validator agent ID to rate
 * @param rating The rating score (0-100, where 0=poor, 100=excellent)
 * @dev Caller must be a registered agent
 * @dev Validator must exist in IdentityRegistry
 * @dev Rating is stored permanently (immutable)
 * @dev Emits ValidatorRated event
 */
function rateValidator(uint256 agentValidatorId, uint8 rating) external;
```

**Parameters:**
- `agentValidatorId` (uint256): The agent ID of the validator being rated
- `rating` (uint8): Quality score from 0 to 100
  - 0-30: Poor (biased, inaccurate, inconsistent)
  - 31-60: Below average (some accuracy issues)
  - 61-80: Good (fair, mostly accurate)
  - 81-100: Excellent (unbiased, accurate, timely)

**Requirements:**
- Caller must be registered in IdentityRegistry
- `agentValidatorId` must exist in IdentityRegistry
- `rating` must be ≤ 100

**Events Emitted:**
```solidity
event ValidatorRated(
    uint256 indexed validatorId,
    uint256 indexed serverId,
    uint8 rating
);
```

**Gas Cost:** ~21,557 gas (measured on Avalanche Fuji)

**Storage:**
```solidity
// Rating stored at: _validatorRatings[validatorId][serverId] = rating
// Existence flag: _hasValidatorRating[validatorId][serverId] = true
```

---

**3. getClientRating**

```solidity
/**
 * @notice Gets the rating a server gave to a client
 * @param agentClientId The client agent ID
 * @param agentServerId The server agent ID who gave the rating
 * @return hasRating True if a rating exists, false otherwise
 * @return rating The rating score (0-100), only valid if hasRating is true
 */
function getClientRating(
    uint256 agentClientId,
    uint256 agentServerId
) external view returns (bool hasRating, uint8 rating);
```

**Parameters:**
- `agentClientId` (uint256): Client being queried
- `agentServerId` (uint256): Server who rated the client

**Returns:**
- `hasRating` (bool): Whether this specific server rated this specific client
- `rating` (uint8): The rating value (only meaningful if hasRating is true)

**Usage Pattern:**
```solidity
// Before serving a client, check their reputation
(bool hasRating, uint8 rating) = registry.getClientRating(clientId, myServerId);

if (hasRating && rating < 70) {
    revert("Client has poor reputation with us, declining service");
}
```

**Gas Cost:** ~3,000 gas (read-only query)

---

**4. getValidatorRating**

```solidity
/**
 * @notice Gets the rating a server gave to a validator
 * @param agentValidatorId The validator agent ID
 * @param agentServerId The server agent ID who gave the rating
 * @return hasRating True if a rating exists, false otherwise
 * @return rating The rating score (0-100), only valid if hasRating is true
 */
function getValidatorRating(
    uint256 agentValidatorId,
    uint256 agentServerId
) external view returns (bool hasRating, uint8 rating);
```

**Parameters:**
- `agentValidatorId` (uint256): Validator being queried
- `agentServerId` (uint256): Server who rated the validator

**Returns:**
- `hasRating` (bool): Whether rating exists
- `rating` (uint8): The rating value

**Usage Pattern:**
```solidity
// Before hiring a validator, check their reputation
(bool hasRating, uint8 rating) = registry.getValidatorRating(validatorId, myServerId);

if (hasRating && rating < 80) {
    // This validator was inaccurate/unfair in past, consider alternatives
}
```

**Gas Cost:** ~3,000 gas (read-only query)

---

#### Unchanged Base EIP-8004 Methods

**These methods remain identical to base specification:**

```solidity
// Feedback authorization (base EIP-8004)
function acceptFeedback(uint256 agentClientId, uint256 agentServerId) external;

// Check feedback authorization (base EIP-8004)
function isFeedbackAuthorized(
    uint256 agentClientId,
    uint256 agentServerId
) external view returns (bool isAuthorized, bytes32 feedbackAuthId);

// Get feedback auth ID (base EIP-8004)
function getFeedbackAuthId(
    uint256 agentClientId,
    uint256 agentServerId
) external view returns (bytes32 feedbackAuthId);
```

**Backward Compatibility:** All base methods have identical signatures, behavior, and gas costs.

---

### Metadata Schema

#### Rating Metadata (Optional Extension)

While ratings are stored as uint8 (0-100), implementations MAY store additional metadata off-chain or in contract events.

**Suggested JSON Schema:**
```json
{
  "rating": 95,
  "timestamp": 1698710400,
  "transactionHash": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb6",
  "raterType": "server",
  "rateeType": "client",
  "context": {
    "serviceType": "data_purchase",
    "transactionValue": "0.01 GLUE",
    "responseTime": "2.3s"
  },
  "comment": "Prompt payment, clear communication" // Optional
}
```

**Fields:**
- `rating` (uint8): On-chain rating value (0-100)
- `timestamp` (uint256): Block timestamp when rating was given
- `transactionHash` (bytes32): Transaction that included the rating
- `raterType` (string): "server" or "validator" (who gave rating)
- `rateeType` (string): "client" or "validator" (who received rating)
- `context` (object): Transaction-specific details
- `comment` (string): Optional text review (off-chain or in events)

**Storage Options:**
1. **On-chain events only** (cheapest, current implementation)
2. **IPFS + event hash** (decentralized storage)
3. **Contract storage** (expensive, not recommended for V1)

**Current Implementation:** Events only (rating stored on-chain, metadata off-chain)

---

### State Transitions

#### Normal Client-Server Transaction Flow

```
┌─────────────────────────────────────────────────────────┐
│  Initial State: Both agents registered                  │
│  - Client: agentId=1, address=0xAAA...                 │
│  - Server: agentId=2, address=0xBBB...                 │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Step 1: Client Requests Service                        │
│  - Client sends payment authorization (EIP-3009)        │
│  - Request sent to server's domain                      │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Step 2: Server Provides Service                        │
│  - Server validates payment authorization               │
│  - Server delivers requested data/service               │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Step 3: Server Rates Client (Bidirectional Extension)  │
│  - Server calls: rateClient(1, 95)                     │
│  - Event emitted: ClientRated(1, 2, 95)                │
│  - Storage: _clientRatings[1][2] = 95                  │
│  - Storage: _hasClientRating[1][2] = true              │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Step 4: Client Rates Server (Custom Implementation)    │
│  - Client stores rating off-chain OR                    │
│  - Uses custom on-chain method (future extension)       │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Final State: Mutual ratings recorded                   │
│  - Client reputation: 95/100 (from server's perspective)│
│  - Server reputation: stored via custom method          │
└─────────────────────────────────────────────────────────┘
```

#### Server-Validator Quality Audit Flow

```
┌─────────────────────────────────────────────────────────┐
│  Initial State: Transaction needs validation            │
│  - Server: agentId=2                                    │
│  - Validator: agentId=3                                 │
│  - Transaction data: available for audit                │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Step 1: Server Requests Validation                     │
│  - Server sends data to validator                       │
│  - Validator audits quality/accuracy                    │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Step 2: Validator Provides Assessment                  │
│  - Validator returns quality score (e.g., 88/100)       │
│  - Assessment stored on-chain or off-chain              │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Step 3: Server Rates Validator (Bidirectional Ext)     │
│  - Server calls: rateValidator(3, 92)                  │
│  - Event emitted: ValidatorRated(3, 2, 92)             │
│  - Storage: _validatorRatings[3][2] = 92               │
│  - Storage: _hasValidatorRating[3][2] = true           │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Final State: Validator reputation updated              │
│  - Validator has 92/100 rating (from this server)       │
│  - Future servers can query before hiring validator     │
└─────────────────────────────────────────────────────────┘
```

#### Reputation Query Before Transaction

```
┌─────────────────────────────────────────────────────────┐
│  New client (agentId=5) requests service from server    │
│  Server (agentId=2) wants to check client reputation    │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Query: getClientRating(5, 2)                           │
│  Returns: (hasRating=false, rating=0)                   │
│  Interpretation: No prior history with this client       │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Decision Path A: No Rating (New Client)                │
│  - Server may choose to serve anyway (trust on first)   │
│  - OR require deposit/collateral for new clients        │
│  - Risk mitigation: start with low-value transactions   │
└─────────────────────────────────────────────────────────┘

                          OR

┌─────────────────────────────────────────────────────────┐
│  Query: getClientRating(6, 2)                           │
│  Returns: (hasRating=true, rating=35)                   │
│  Interpretation: Bad prior experience with this client   │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Decision Path B: Low Rating (Bad Client)               │
│  - Server declines service (self-protection)            │
│  - Client is naturally filtered by market               │
│  - No platform arbitration needed                       │
└─────────────────────────────────────────────────────────┘
```

---

### Example Transactions

#### Example 1: karma-hello Rates Client

**Scenario:** karma-hello agent (server) sells chat logs to abracadabra agent (client)

**Contract Call:**
```solidity
// karma-hello's contract call
ReputationRegistry registry = ReputationRegistry(REPUTATION_REGISTRY_ADDRESS);

registry.rateClient(
    abracadabra_agent_id,  // 2 (client being rated)
    95                      // Excellent client
);
```

**Python Implementation:**
```python
from web3 import Web3
from eth_account import Account

# karma-hello agent
w3 = Web3(Web3.HTTPProvider(RPC_URL))
registry = w3.eth.contract(address=REPUTATION_REGISTRY, abi=ABI)
karma_hello_account = Account.from_key(KARMA_HELLO_PRIVATE_KEY)

# Rate abracadabra as excellent client
tx = registry.functions.rateClient(
    abracadabra_agent_id,  # uint256
    95                      # uint8 (0-100)
).build_transaction({
    'from': karma_hello_account.address,
    'gas': 100000,
    'gasPrice': w3.eth.gas_price,
    'nonce': w3.eth.get_transaction_count(karma_hello_account.address)
})

signed_tx = karma_hello_account.sign_transaction(tx)
tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)

# Wait for confirmation
receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
print(f"Client rated! Tx: {tx_hash.hex()}")
```

**On-Chain Result:**
- Event emitted: `ClientRated(2, 1, 95)` (client=abracadabra, server=karma-hello, rating=95)
- Storage updated: `_clientRatings[2][1] = 95`
- Gas used: ~21,557 gas

---

#### Example 2: Check Client Reputation Before Serving

**Scenario:** karma-hello receives request from unknown client, checks reputation first

**Contract Query:**
```solidity
(bool hasRating, uint8 rating) = registry.getClientRating(
    unknown_client_id,
    karma_hello_agent_id
);

if (hasRating && rating < 70) {
    revert("Client has poor reputation, declining service");
}

// Otherwise, proceed with service
```

**Python Implementation:**
```python
# Before serving request
has_rating, rating = registry.functions.getClientRating(
    client_id,
    karma_hello_agent_id
).call()

if has_rating and rating < 70:
    raise Exception(f"Client has poor reputation ({rating}/100), declining")

# Reputation acceptable, provide service
logs = get_chat_logs()
return logs
```

**Decision Logic:**
- `hasRating=false` → New client, may serve (trust on first transaction)
- `hasRating=true, rating≥70` → Good reputation, serve
- `hasRating=true, rating<70` → Poor reputation, decline

---

#### Example 3: Validator Agent Rates Multiple Servers

**Scenario:** Validator agent assesses quality for 3 different servers

**Contract Calls:**
```solidity
// Server A rates validator
registry.rateValidator(validator_id, 88); // Good but some issues

// Server B rates validator
registry.rateValidator(validator_id, 95); // Excellent

// Server C rates validator
registry.rateValidator(validator_id, 65); // Below average
```

**Query Validator Reputation:**
```python
# Aggregate validator ratings from multiple servers
ratings = []
for server_id in [server_a_id, server_b_id, server_c_id]:
    has_rating, rating = registry.functions.getValidatorRating(
        validator_id,
        server_id
    ).call()

    if has_rating:
        ratings.append(rating)

# Calculate average validator reputation
avg_rating = sum(ratings) / len(ratings) if ratings else 0
# avg_rating = (88 + 95 + 65) / 3 = 82.67 (good validator)
```

**Note:** On-chain aggregation (average calculation) is NOT in V1 scope. Implementations aggregate off-chain or use external indexers.

---

## Rationale

### Design Decisions

#### Decision 1: Separate `rateClient()` and `rateValidator()` Methods

**Alternatives Considered:**

**Option A: Single `rate()` method with role enum**
```solidity
enum Role { CLIENT, VALIDATOR }
function rate(uint256 agentId, uint8 rating, Role role) external;
```

**Rejected Because:**
- More complex (3 parameters vs 2)
- Role enum adds gas cost (storage + checking)
- Less type-safe (easy to pass wrong role)
- Harder to query (need role in query too)

**Option B: Unified rating (no role distinction)**
```solidity
function rate(uint256 agentId, uint8 rating) external;
```

**Rejected Because:**
- Conflates different skill sets (client vs validator)
- Can't specialize (some agents only validate, never buy)
- Loses granularity (server with 95% client rating but 40% validator rating)

**Chosen: Separate methods**
- ✅ Clear semantics (`rateClient` vs `rateValidator` = obvious intent)
- ✅ Type safety (compiler prevents wrong method call)
- ✅ Gas efficient (no role enum storage)
- ✅ Separate reputation tracks (client skill ≠ validator skill)

---

#### Decision 2: Rating Scale 0-100 (Not 1-5 Stars)

**Alternatives Considered:**

**Option A: 1-5 star scale (like Uber/Airbnb)**
```solidity
function rateClient(uint256 agentId, uint8 stars) external;
// stars = 1, 2, 3, 4, or 5
```

**Rejected Because:**
- Low granularity (only 5 values)
- Star inflation (most ratings are 4-5 stars, little differentiation)
- Harder to aggregate (averaging stars less intuitive)

**Option B: 0-10 scale**
```solidity
function rateClient(uint256 agentId, uint8 rating) external;
// rating = 0 to 10
```

**Rejected Because:**
- Still relatively low granularity
- Not standard in smart contracts

**Chosen: 0-100 scale**
- ✅ High granularity (101 possible values)
- ✅ Intuitive (percentage-based: 95/100 = 95% quality)
- ✅ Avoids inflation (more room for differentiation)
- ✅ Easy to aggregate (simple averaging)
- ✅ Used in EIP-8004 base discussions (consistency)

---

#### Decision 3: Immutable Ratings (No Delete/Edit)

**Alternatives Considered:**

**Option A: Editable ratings**
```solidity
function updateClientRating(uint256 agentId, uint8 newRating) external;
```

**Rejected Because:**
- Enables manipulation (change rating under pressure)
- Loses historical record (what was original rating?)
- Complicates queries (need timestamp + version tracking)
- Trust issues (did rating change legitimately or maliciously?)

**Option B: Time-limited ratings (expire after X days)**
```solidity
struct Rating {
    uint8 value;
    uint256 timestamp;
    uint256 expiresAt;
}
```

**Rejected Because:**
- Adds complexity (expiration checking)
- Loses long-term reputation signal
- Arbitrary expiration time (who decides?)
- V2 enhancement (reputation decay)

**Chosen: Immutable ratings**
- ✅ Simple (no edit/delete logic)
- ✅ Honest (can't change rating retroactively)
- ✅ Auditable (rating is permanent record)
- ✅ Incentivizes careful rating (can't undo mistakes)
- ⚠️ Trade-off: Mistakes are permanent (accepted for V1 simplicity)

**Future Enhancement (V2):** Reputation decay (older ratings weigh less)

---

#### Decision 4: No Self-Rating Prevention in V1

**Issue:** Agent could rate themselves as a client
```solidity
// Nothing prevents this in V1
agent1.rateClient(agent1_id, 100); // Self-rate as perfect client
```

**Why Not Prevented in V1:**
- Adds complexity (need to resolve caller's agentId, check equality)
- Increases gas cost (~5,000 additional gas for resolution + check)
- Limited impact (self-ratings are obvious manipulation, ignored by queriers)
- V2 enhancement (add `CannotRateSelf()` error)

**Mitigation:**
- Off-chain indexers filter self-ratings
- Reputation aggregators exclude self-ratings
- Community norms discourage self-rating

**V2 Fix:**
```solidity
function rateClient(uint256 agentClientId, uint8 rating) external {
    uint256 serverAgentId = identityRegistry.resolveByAddress(msg.sender).agentId;

    if (agentClientId == serverAgentId) {
        revert CannotRateSelf();
    }

    // ... rest of function
}
```

---

#### Decision 5: Ratings Per Server (Not Global Average)

**Storage Design:**
```solidity
// Chosen: Per-server ratings
mapping(uint256 => mapping(uint256 => uint8)) private _clientRatings;
//         clientId       serverId       rating

// NOT chosen: Global average
mapping(uint256 => uint256) private _clientAverageRating;
//         clientId       average
```

**Why Per-Server:**
- ✅ Preserves granularity (see specific experiences)
- ✅ Enables relationship context (Client may be great for Server A, bad for Server B)
- ✅ Avoids on-chain averaging (expensive, gas-intensive)
- ✅ Flexibility (off-chain can aggregate however desired)

**Trade-Off:**
- More storage (O(n×m) for n clients and m servers)
- Queries are per-server (not global)
- Aggregation happens off-chain

**Solution:** Off-chain indexers (The Graph, etc.) aggregate ratings for global view

---

### Alternative Approaches Considered

#### Alternative 1: Reputation Tokens (NFTs)

**Concept:** Each rating is an NFT minted to the rated agent
```solidity
function rateClient(uint256 clientId, uint8 rating) external {
    // Mint NFT to client with rating metadata
    reputationNFT.mint(clientId, rating);
}
```

**Rejected Because:**
- ✅ Pro: Portable (NFTs transfer across chains)
- ❌ Con: Expensive (NFT minting ~80,000 gas vs ~21,000 for simple storage)
- ❌ Con: Overkill (ratings don't need NFT features like ownership transfer)
- ❌ Con: Query complexity (need to iterate through NFTs)

---

#### Alternative 2: Merkle Tree Storage

**Concept:** Store ratings in Merkle tree, only root on-chain
```solidity
bytes32 public ratingsRoot; // Merkle root of all ratings
```

**Rejected Because:**
- ✅ Pro: Cheaper storage (only root on-chain)
- ❌ Con: Complex queries (need Merkle proof for every query)
- ❌ Con: Centralization risk (who maintains tree off-chain?)
- ❌ Con: No real-time updates (tree rebuild needed)

---

#### Alternative 3: Soulbound Tokens (SBTs)

**Concept:** Ratings as non-transferable tokens bound to agent
```solidity
function rateClient(uint256 clientId, uint8 rating) external {
    soulboundToken.bind(clientId, rating);
}
```

**Rejected Because:**
- Similar issues to NFTs (complexity, gas cost)
- SBT standard not finalized (EIP draft)
- Over-engineering for simple ratings

---

## Backward Compatibility

### Zero Breaking Changes Proof

**Claim:** This extension introduces ZERO breaking changes to base EIP-8004

**Proof:**

#### 1. Interface Compatibility

**Base EIP-8004 ReputationRegistry:**
```solidity
interface IReputationRegistry {
    function acceptFeedback(uint256 agentClientId, uint256 agentServerId) external;
    function isFeedbackAuthorized(uint256 clientId, uint256 serverId)
        external view returns (bool isAuthorized, bytes32 feedbackAuthId);
    function getFeedbackAuthId(uint256 clientId, uint256 serverId)
        external view returns (bytes32 feedbackAuthId);
}
```

**Bidirectional Extension:**
```solidity
interface IReputationRegistryBidirectional is IReputationRegistry {
    // Base methods: UNCHANGED (inherited)
    // New methods: ADDED (not replacing)
    function rateClient(uint256 agentClientId, uint8 rating) external;
    function rateValidator(uint256 agentValidatorId, uint8 rating) external;
    function getClientRating(uint256 clientId, uint256 serverId)
        external view returns (bool hasRating, uint8 rating);
    function getValidatorRating(uint256 validatorId, uint256 serverId)
        external view returns (bool hasRating, uint8 rating);
}
```

**Result:** Bidirectional interface is a superset (all base methods present + new methods)

---

#### 2. Storage Layout Compatibility

**Base storage:**
```solidity
mapping(bytes32 => bool) private _feedbackAuthorizations;  // Slot 0
mapping(uint256 => mapping(uint256 => bytes32)) private _clientServerToAuthId;  // Slot 1
```

**Extended storage:**
```solidity
// Base storage: UNCHANGED (slots 0-1)
mapping(bytes32 => bool) private _feedbackAuthorizations;  // Slot 0
mapping(uint256 => mapping(uint256 => bytes32)) private _clientServerToAuthId;  // Slot 1

// New storage: ADDED (slots 2-5, no conflicts)
mapping(uint256 => mapping(uint256 => uint8)) private _clientRatings;  // Slot 2
mapping(uint256 => mapping(uint256 => bool)) private _hasClientRating;  // Slot 3
mapping(uint256 => mapping(uint256 => uint8)) private _validatorRatings;  // Slot 4
mapping(uint256 => mapping(uint256 => bool)) private _hasValidatorRating;  // Slot 5
```

**Result:** No storage slot conflicts (new storage uses different slots)

---

#### 3. Event Compatibility

**Base events:**
```solidity
event AuthFeedback(uint256 indexed agentClientId, uint256 indexed agentServerId, bytes32 feedbackAuthId);
```

**Extended events:**
```solidity
// Base events: UNCHANGED
event AuthFeedback(uint256 indexed agentClientId, uint256 indexed agentServerId, bytes32 feedbackAuthId);

// New events: ADDED
event ClientRated(uint256 indexed clientId, uint256 indexed serverId, uint8 rating);
event ValidatorRated(uint256 indexed validatorId, uint256 indexed serverId, uint8 rating);
```

**Result:** Base event unchanged, new events don't conflict

---

#### 4. Deployment Compatibility

**Scenario: Base contract deployed, then extended contract deployed**

```
Network: Avalanche Fuji

Base Deployment:
- IdentityRegistry: 0x123...
- ReputationRegistry (base): 0x456...
- Agents use acceptFeedback() ✅

Extended Deployment:
- IdentityRegistry: 0x123... (reuse same, unchanged)
- ReputationRegistry (extended): 0x789... (new deployment)
- Old agents: continue using 0x456... ✅ (still works)
- New agents: use 0x789... ✅ (backward compatible + new methods)
```

**Result:** Both contracts coexist, old agents unaffected

---

#### 5. Client Code Compatibility

**Old client code (written for base):**
```python
registry = ReputationRegistry(BASE_ADDRESS)
registry.acceptFeedback(client_id, server_id)  # Base method
```

**Same code with extended contract:**
```python
registry = ReputationRegistryBidirectional(EXTENDED_ADDRESS)
registry.acceptFeedback(client_id, server_id)  # ✅ Still works (inherited)
```

**New client code (using extension):**
```python
registry = ReputationRegistryBidirectional(EXTENDED_ADDRESS)
registry.acceptFeedback(client_id, server_id)  # Base method
registry.rateClient(client_id, 95)  # New method
```

**Result:** Old code runs on new contract without changes

---

### Migration Strategy

**Phase 1: Base EIP-8004**
- Agents deployed with base ReputationRegistry
- System operational with acceptFeedback()

**Phase 2: Extended Deployment (No Disruption)**
- Deploy new ReputationRegistry (bidirectional)
- Point new agents to new contract
- Old agents keep using old contract (not forced to migrate)

**Phase 3: Gradual Adoption**
- Agents migrate at their own pace
- Both contracts valid (no deprecation)
- Ecosystem standardizes organically

**Timeline:** 1-2 years for full adoption (no forced timeline)

---

## Security Considerations

### Attack Vectors

#### 1. Sybil Attacks (Week 3 Analysis)

**Attack:** Create multiple fake agents to inflate reputation via mutual rating

**Cost:** $13 for 10 fake agents (0.08 AVAX registration each + faucet costs)

**Detection:**
- Graph clustering: 95% accuracy (Week 3 Day 1 findings)
- Temporal analysis: Rating bursts from new accounts
- Statistical outliers: Agents with only mutual ratings (no diverse raters)

**Mitigation:**
- Off-chain: Graph analysis filters suspicious clusters
- On-chain (V2): Stake requirements, identity verification
- Economic: Attack unprofitable (need 50+ fake agents to profit, detection rate 95%)

**Expected Value:**
```
EV = (Benefit × Success Rate) - (Cost × Detection Rate)
EV = ($200 × 0.05) - ($13 × 0.95)
EV = $10 - $12.35 = -$2.35 (unprofitable)
```

---

#### 2. Rating Manipulation (Collusion)

**Attack:** Agents collude to exchange high ratings (inflate reputation)

**Cost:** $0.90 (gas costs for mutual transactions)

**Detection:**
- 92% accuracy (Week 3 Day 2 findings)
- Reciprocal rating pattern (A rates B high, B rates A high)
- Transaction velocity anomalies
- No third-party ratings (only rate each other)

**Mitigation:**
- Off-chain: Flag agents with >80% reciprocal ratings
- Social: Community identifies collusion via graph analysis
- Economic: Reputation value > collusion gains (Nash equilibrium)

**Game Theory:**
```
If both collude: Short-term gain (high ratings), but community detects → reputation loss
If one defects: Defector gets honest reputation, colluder exposed
Nash Equilibrium: Both rate honestly (dominant strategy when detection > 50%)
```

---

#### 3. Retaliatory Ratings

**Attack:** Server gives low rating to client in retaliation for client's low rating

**Scenario:**
1. Client receives service (quality is poor)
2. Client plans to rate server 2/5
3. Server anticipates negative rating
4. Server rates client 1/5 (retaliation)

**Mitigation:**
- **Commit-Reveal** (future enhancement, Week 4 Day 2 design):
  ```solidity
  // Phase 1: Commit hash (rating hidden)
  function commitRating(bytes32 ratingHash) external;

  // Phase 2: Reveal (after both committed)
  function revealRating(uint256 agentId, uint8 rating, uint256 nonce) external;
  ```
- **Social:** Retaliatory patterns visible (agent with many 0-10 ratings is flagged)
- **V1 Acceptance:** Some retaliation possible, mitigated by reputation aggregation

---

#### 4. Self-Rating (Not Prevented in V1)

**Attack:** Agent rates themselves as perfect client
```solidity
agent.rateClient(own_agent_id, 100);
```

**Impact:** Limited (obvious manipulation, filtered by indexers)

**Mitigation:**
- Off-chain: Exclude self-ratings from aggregation
- On-chain V2: Add `CannotRateSelf()` check (costs ~5K gas)

**Why V1 Allows:**
- Simplicity (no check logic)
- Low impact (self-ratings are transparent, easily filtered)
- Gas savings (~5K per rating)

---

#### 5. Spam Ratings (Gas Griefing)

**Attack:** Malicious agent spams ratings to bloat storage
```solidity
for (uint i = 0; i < 1000; i++) {
    registry.rateClient(victim_id, 50);
}
```

**Cost to Attacker:** ~21,000 gas per rating × 1,000 = 21M gas (~$600 on mainnet)

**Impact:** Storage bloat, but attacker pays gas

**Mitigation:**
- Economic: Expensive for attacker (pays all gas)
- Query optimization: Indexers aggregate (ignore duplicate ratings)
- V2: Rate limiting (max N ratings per agent pair per time period)

---

#### 6. Front-Running

**Attack:** Observer sees pending rating, front-runs with own rating
```
Pending tx: Alice rates Bob (95)
Attacker sees: Creates tx with higher gas to rate Bob first (10)
Result: Attacker's low rating executes first
```

**Impact:** Minimal (both ratings are stored, not replaced)

**Mitigation:**
- Not a concern: Multiple ratings per pair are allowed
- Aggregation: Off-chain calculates average (order doesn't matter)

---

### Gas Limit Considerations

**Maximum Ratings Per Block:**
- Block gas limit: 15,000,000 gas (Ethereum mainnet)
- Gas per rating: ~21,557 gas
- Max ratings per block: 15M / 21,557 ≈ 696 ratings

**Avalanche C-Chain:**
- Block gas limit: 15,000,000 gas
- Block time: 2 seconds
- Theoretical throughput: 348 ratings/second

**Scalability:** Not a bottleneck (696 ratings/block >> expected usage)

---

### Upgrade Path Security

**Immutability Principle:** Once deployed, contracts cannot be upgraded

**Risk Mitigation:**
- Thorough testing (29 tests, 100% passing, Week 1)
- Audit (Week 3 code audit, 0 critical vulnerabilities)
- Real-world validation (99 transactions, Week 2)
- Gradual rollout (testnet → mainnet)

**If Critical Bug Found:**
- Deploy new contract (new address)
- Announce to community (GitHub, forums, social)
- Agents migrate (point to new address)
- Old contract remains (historical data preserved)

**V2 Improvements:**
- Self-rating prevention
- Commit-reveal for anti-retaliation
- Reputation decay (time-weighted)
- Rate limiting (spam prevention)

---

## Reference Implementation

**Full implementation available:**
- Repository: github.com/ultravioletadao/karmacadabra
- Path: `erc-8004/contracts/src/ReputationRegistry.sol`
- Tests: `erc-8004/contracts/test/ReputationRegistry.t.sol` (29 tests, 100% passing)
- Deployment: Avalanche Fuji testnet at `0x63B...2b2` (99 real transactions)

**Key Files:**
- Solidity contracts: `erc-8004/contracts/src/`
- Python integration: `shared/base_agent.py`
- Test suite: `erc-8004/contracts/test/`

---

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).

---

**Status:** ✅ DAY 2 COMPLETE
**Time:** 4 hours
**Output:** Complete formal specification (contract interface, state transitions, rationale, backward compatibility, security)
**Next:** Day 3 - Implementation guide with step-by-step integration instructions and code examples
