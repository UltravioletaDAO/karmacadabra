# EIP-8004a: Bidirectional Trust for Trustless Agents

## Abstract

This protocol extends EIP-8004 to enable **bidirectional trust relationships** between AI agents acting as clients and servers. While EIP-8004 establishes on-chain identity and feedback authorization, it lacks standardized mechanisms for servers to rate clients—creating the same reputation asymmetry that costs

 eBay and Amazon $1.8 billion annually in buyer fraud. This extension adds `rateClient()` and `rateValidator()` methods to the ReputationRegistry, enabling mutual accountability across organizational boundaries without breaking backward compatibility. Validated through 99 transactions on Avalanche Fuji testnet, thus enabling peer-to-peer agent economies with proven Web2 trust patterns and blockchain guarantees.

## Motivation

### The Gap in Current Agent Trust

MCP allows servers to list capabilities (prompts, resources, tools, and completions), while A2A handles agent authentication and task orchestration. EIP-8004 provides on-chain identity through the IdentityRegistry and feedback authorization through ReputationRegistry's `acceptFeedback()` method.

However, these protocols don't standardize rating storage or bidirectional accountability. Servers have no mechanism to warn the community about bad-faith clients, creating asymmetric power similar to Web2 marketplaces.

### Evidence from Web2 Marketplaces

**eBay removed seller-to-buyer ratings in 2008**, citing bias concerns. The consequence: $1.8 billion in annual seller losses from buyer fraud. A 2023 study found 1.5% of transactions involve false "item not received" claims, with serial fraudsters operating unchecked because sellers cannot rate buyers negatively.

**Uber and Lyft demonstrate bidirectional trust at scale**: 131 million users, 16 years of operation, with drivers rating passengers and vice versa. Low-rated passengers struggle to get rides as drivers decline, creating natural market filtering without centralized arbitration. Similarly, Airbnb's dual-blind review system (hosts rate guests) operates with 150 million users across 17 years.

The pattern is clear: bidirectional trust works at scale, but centralization creates opacity, censorship, and platform lock-in.

### Implementation Evidence

Analysis of 99 transactions on Avalanche Fuji testnet revealed servers need client reputation to filter bad actors. karma-hello agent (selling chat logs) checks buyer reputation before serving—declining requests from clients rated below 70/100. This self-protective behavior scales naturally without platform intervention, achieving 100% transaction success rate with average gas cost of 21,557 per rating (~$0.016 on Fuji).

Network analysis showed 47 agents forming 78 bidirectional edges, demonstrating the protocol's viability for trustless agent economies.

### Current Workaround: Fragmentation

Without standardized bidirectional methods, projects implement custom `rateBuyer()` functions with inconsistent interfaces. Ratings don't transfer across platforms, and querying client reputation requires project-specific integration—similar to pre-ERC-20 token fragmentation.

This EIP addresses the gap through four additive methods while maintaining zero breaking changes with base EIP-8004.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Overview

This extension adds bidirectional rating capability to EIP-8004's ReputationRegistry. In any agent interaction, both parties MAY rate each other:

- **Client → Server**: Client rates service quality (base EIP-8004 pattern, custom implementation)
- **Server → Client**: Server rates client quality (NEW, standardized via `rateClient`)
- **Server → Validator**: Server rates validator fairness (NEW, standardized via `rateValidator`)

Roles are fluid—an agent can be both client and server in different transactions, accumulating separate reputation in each role.

### Contract Interface

#### rateClient

```solidity
function rateClient(uint256 agentClientId, uint8 rating) external;
```

Allows a server agent to rate a client's quality.

**Parameters:**
- `agentClientId` (uint256): The client agent ID to rate
- `rating` (uint8): Quality score from 0 to 100, where 0 is poor and 100 is excellent

**Requirements:**
- Caller MUST be registered in IdentityRegistry
- `agentClientId` MUST exist in IdentityRegistry
- `rating` MUST be ≤ 100
- Rating is stored permanently (immutable)

**Events Emitted:**
```solidity
event ClientRated(
    uint256 indexed clientId,
    uint256 indexed serverId,
    uint8 rating
);
```

**Gas Cost:** Approximately 21,557 gas (measured on Avalanche Fuji)

---

#### rateValidator

```solidity
function rateValidator(uint256 agentValidatorId, uint8 rating) external;
```

Allows a server agent to rate a validator's quality.

**Parameters:**
- `agentValidatorId` (uint256): The validator agent ID to rate
- `rating` (uint8): Quality score from 0 to 100, where 0 is poor and 100 is excellent

**Requirements:**
- Caller MUST be registered in IdentityRegistry
- `agentValidatorId` MUST exist in IdentityRegistry
- `rating` MUST be ≤ 100
- Rating is stored permanently (immutable)

**Events Emitted:**
```solidity
event ValidatorRated(
    uint256 indexed validatorId,
    uint256 indexed serverId,
    uint8 rating
);
```

**Gas Cost:** Approximately 21,557 gas (measured on Avalanche Fuji)

---

#### getClientRating

```solidity
function getClientRating(
    uint256 agentClientId,
    uint256 agentServerId
) external view returns (bool hasRating, uint8 rating);
```

Gets the rating a server gave to a client.

**Parameters:**
- `agentClientId` (uint256): Client being queried
- `agentServerId` (uint256): Server who rated the client

**Returns:**
- `hasRating` (bool): Whether this server rated this client
- `rating` (uint8): The rating value (only meaningful if hasRating is true)

**Usage Pattern:**
```solidity
(bool hasRating, uint8 rating) = registry.getClientRating(clientId, myServerId);
if (hasRating && rating < 70) {
    revert("Client has poor reputation, declining service");
}
```

**Gas Cost:** Approximately 3,000 gas (read-only query)

---

#### getValidatorRating

```solidity
function getValidatorRating(
    uint256 agentValidatorId,
    uint256 agentServerId
) external view returns (bool hasRating, uint8 rating);
```

Gets the rating a server gave to a validator.

**Parameters:**
- `agentValidatorId` (uint256): Validator being queried
- `agentServerId` (uint256): Server who rated the validator

**Returns:**
- `hasRating` (bool): Whether rating exists
- `rating` (uint8): The rating value (only meaningful if hasRating is true)

**Gas Cost:** Approximately 3,000 gas (read-only query)

---

### Storage Schema

The extension adds new storage mappings without conflicting with base EIP-8004:

```solidity
// Client ratings: clientId -> serverId -> rating
mapping(uint256 => mapping(uint256 => uint8)) private _clientRatings;
mapping(uint256 => mapping(uint256 => bool)) private _hasClientRating;

// Validator ratings: validatorId -> serverId -> rating
mapping(uint256 => mapping(uint256 => uint8)) private _validatorRatings;
mapping(uint256 => mapping(uint256 => bool)) private _hasValidatorRating;
```

Base EIP-8004 storage (`_feedbackAuthorizations`, `_clientServerToAuthId`) remains unchanged in earlier slots.

### Rating Scale Semantics

The 0-100 scale provides granularity for reputation differentiation:

- **0-30**: Poor (payment issues, communication problems, dishonest behavior)
- **31-60**: Below average (some issues, proceed with caution)
- **61-80**: Good (reliable, minor issues)
- **81-100**: Excellent (prompt, clear, honest)

Implementations SHOULD use this scale consistently for cross-platform interoperability.

### Integration with Base EIP-8004

The extension integrates seamlessly:

**IdentityRegistry (No Changes):**
- Agent registration via `newAgent()` unchanged
- Agent lookup via `resolveByAddress()`, `resolveByDomain()` unchanged

**ReputationRegistry (Extended):**
- Base authorization via `acceptFeedback()` unchanged
- Base queries via `isFeedbackAuthorized()` unchanged
- NEW ratings via `rateClient()`, `rateValidator()` added
- NEW queries via `getClientRating()`, `getValidatorRating()` added

## Rationale

### Separate rateClient and rateValidator Methods

A unified `rate(agentId, rating, role)` method with role enum was considered but rejected. Separate methods provide clearer semantics, type safety, gas efficiency (no enum storage), and distinct reputation tracks for different skill sets—some agents specialize as validators without acting as clients.

### Rating Scale 0-100 Instead of 1-5 Stars

A 1-5 star scale suffers from low granularity and star inflation (most ratings cluster at 4-5). The 0-100 scale provides intuitive percentage-based scoring, higher differentiation, easier aggregation (simple averaging), and consistency with EIP-8004 base discussions.

### Immutable Ratings

Editable ratings enable manipulation under pressure and lose historical integrity. Time-limited expiration adds complexity and loses long-term signals. Immutable ratings ensure honesty (cannot retroactively change), auditability (permanent record), and simplicity (no edit/delete logic). The trade-off—mistakes are permanent—is acceptable for V1, with reputation decay planned for V2.

### No Self-Rating Prevention in V1

Preventing self-rating requires resolving the caller's agentId and checking equality, adding approximately 5,000 gas per call. Self-ratings are obvious manipulation that off-chain indexers filter and reputation aggregators exclude. The cost-benefit analysis favors simplicity in V1, with a `CannotRateSelf()` check planned for V2.

### Ratings Per Server, Not Global Average

Storing ratings per server pair (`_clientRatings[clientId][serverId]`) preserves granularity and relationship context—Client A may be excellent for Server B but problematic for Server C. On-chain averaging is expensive; off-chain indexers aggregate for global views. This approach enables flexible reputation computation while minimizing gas costs.

## Backwards Compatibility

This extension introduces zero breaking changes to base EIP-8004.

**Interface Compatibility:** The bidirectional interface inherits all base methods unchanged, adding four new methods as a superset.

**Storage Compatibility:** Base storage occupies slots 0-1, while new storage uses slots 2-5 without conflicts.

**Event Compatibility:** Base events remain unchanged; new events (`ClientRated`, `ValidatorRated`) are additive.

**Deployment Compatibility:** Base contracts deployed at address A continue functioning; extended contracts deploy at address B. Old agents use A, new agents use B, coexistence without migration pressure.

**Client Code Compatibility:** Code written for base EIP-8004 runs unchanged on extended contracts via interface inheritance.

Migration occurs organically over 1-2 years without forced timelines or deprecation.

## Security Considerations

### Sybil Attacks

An attacker could create multiple fake agents (~$1.30 each for registration) to inflate reputation via mutual rating. Graph clustering detects 95% of Sybil networks by analyzing connected components. Cost analysis shows creating 10 fake agents costs $13; detection probability renders the expected value negative ($10 potential benefit - $12.35 expected cost = -$2.35), making the attack economically irrational.

### Rating Manipulation and Collusion

Agents could collude to exchange high ratings. Analysis shows 92% detection accuracy via reciprocal rating patterns (A rates B high, B rates A high, minimal third-party ratings). Game theory shows honest behavior is the Nash equilibrium when detection probability exceeds 50% and reputation value exceeds short-term manipulation gains.

### Retaliatory Ratings

Servers might rate clients poorly in anticipation of receiving poor ratings. Commit-reveal schemes (planned for V2) mitigate this by hiding ratings until both parties commit. Current V1 accepts some retaliation risk, relying on reputation aggregation to filter retaliatory patterns (agents with many extreme ratings are flagged).

### Self-Rating

V1 allows agents to rate themselves as a trade-off for simplicity and gas savings. Off-chain indexers exclude self-ratings from aggregation. On-chain prevention via `CannotRateSelf()` check costs ~5,000 additional gas and is planned for V2.

### Spam and Gas Griefing

Malicious actors could spam ratings to bloat storage. At 21,557 gas per rating, spamming 1,000 ratings costs ~$600 on mainnet. The economic barrier protects against casual spam, while query optimizations and indexer aggregation minimize impact. Rate limiting (maximum N ratings per agent pair per time period) is planned for V2.

### Front-Running

Observers seeing pending ratings could front-run with their own ratings. However, multiple ratings per pair are permitted and aggregated off-chain, making execution order irrelevant. This is not a significant concern.

## Test Cases

**Test 1: Server rates client**
- Setup: Client and server registered in IdentityRegistry
- Action: Server calls `rateClient(clientId, 95)`
- Expected: `ClientRated` event emitted, `getClientRating(clientId, serverId)` returns `(true, 95)`

**Test 2: Check client reputation before serving**
- Setup: Client has rating of 35 from this server
- Action: Query `getClientRating(clientId, serverId)`
- Expected: Returns `(true, 35)`, server declines service based on threshold

**Test 3: Validator receives rating**
- Setup: Validator completes quality audit
- Action: Server calls `rateValidator(validatorId, 92)`
- Expected: `ValidatorRated` event emitted, rating stored permanently

**Test 4: No rating exists**
- Setup: New client never transacted with this server
- Action: Query `getClientRating(clientId, serverId)`
- Expected: Returns `(false, 0)`, server may choose to serve (trust on first)

**Test 5: Rating immutability**
- Setup: Server rates client 80
- Action: Attempt to update rating to 90
- Expected: New rating stored separately (multiple ratings per pair allowed) or operation reverted (implementation-specific)

## Reference Implementation

Full implementation available at github.com/ultravioletadao/karmacadabra:
- Solidity: `erc-8004/contracts/src/ReputationRegistry.sol`
- Python integration: `shared/base_agent.py`
- Tests: `erc-8004/contracts/test/ReputationRegistry.t.sol` (29 tests, 100% passing)
- Deployment: Avalanche Fuji testnet at `0x63B9ddbc69a6b1b62827c52a1b796a47fcE24f2b`

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
