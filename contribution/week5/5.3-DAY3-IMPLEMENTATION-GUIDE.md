# Implementing EIP-8004 Bidirectional Trust

**Week 5 Day 3:** Implementation Guide
**Date:** November 1, 2025
**Audience:** Developers integrating bidirectional trust into AI agent systems

---

## Overview

This guide walks you through integrating EIP-8004 bidirectional trust into your agent system. By the end, you'll be able to:
- ✅ Deploy IdentityRegistry and ReputationRegistry contracts
- ✅ Register agents on-chain
- ✅ Rate clients and validators
- ✅ Query reputation before transactions
- ✅ Test the complete workflow

**Estimated Time:** 2 hours (following this guide)

---

## Getting Started

### Prerequisites

**Required:**
- Node.js v18+ and npm
- Foundry (Forge, Cast, Anvil)
- Python 3.9+ with web3.py
- Git

**Recommended:**
- Basic Solidity knowledge
- Familiarity with Web3.py or ethers.js
- Understanding of EVM transaction flow

**Install Tools:**

```bash
# Install Foundry
curl -L https://foundry.paradigm.xyz | bash
foundryup

# Install Python dependencies
pip install web3 eth-account python-dotenv

# Verify installations
forge --version
python --version
```

---

### Environment Setup

**1. Clone Repository:**

```bash
git clone https://github.com/ultravioletadao/karmacadabra.git
cd karmacadabra/erc-8004
```

**2. Create Environment File:**

```bash
cp .env.example .env
```

**3. Configure `.env`:**

```bash
# RPC endpoint (Avalanche Fuji testnet)
RPC_URL_FUJI=https://api.avax-test.network/ext/bc/C/rpc

# Your deployer private key (for contract deployment)
PRIVATE_KEY=0x...  # NEVER commit this!

# Contract addresses (will be populated after deployment)
IDENTITY_REGISTRY=
REPUTATION_REGISTRY=
```

**4. Get Testnet AVAX:**

Visit https://faucet.avax.network/ and request testnet AVAX for your deployer address.

**Verify Balance:**
```bash
cast balance $YOUR_ADDRESS --rpc-url $RPC_URL_FUJI
# Should show > 1 AVAX
```

---

## Contract Deployment

### Step 1: Deploy IdentityRegistry

**Compile Contracts:**

```bash
cd contracts
forge build
```

**Expected Output:**
```
[⠊] Compiling...
[⠒] Compiling 15 files with 0.8.19
[⠢] Solc 0.8.19 finished in 3.21s
Compiler run successful!
```

**Deploy IdentityRegistry:**

```bash
forge create src/IdentityRegistry.sol:IdentityRegistry \
    --rpc-url $RPC_URL_FUJI \
    --private-key $PRIVATE_KEY
```

**Expected Output:**
```
Deployer: 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb6
Deployed to: 0x1234567890abcdef1234567890abcdef12345678
Transaction hash: 0xabcd...
```

**Save Address:**

```bash
# Add to .env
IDENTITY_REGISTRY=0x1234567890abcdef1234567890abcdef12345678
```

---

### Step 2: Deploy ReputationRegistry (Bidirectional)

**Deploy with IdentityRegistry Reference:**

```bash
forge create src/ReputationRegistry.sol:ReputationRegistry \
    --rpc-url $RPC_URL_FUJI \
    --private-key $PRIVATE_KEY \
    --constructor-args $IDENTITY_REGISTRY
```

**Expected Output:**
```
Deployer: 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb6
Deployed to: 0xabcdef1234567890abcdef1234567890abcdef12
Transaction hash: 0x1234...
```

**Save Address:**

```bash
# Add to .env
REPUTATION_REGISTRY=0xabcdef1234567890abcdef1234567890abcdef12
```

---

### Step 3: Verify Contracts on Snowtrace

**Verify IdentityRegistry:**

```bash
forge verify-contract \
    $IDENTITY_REGISTRY \
    src/IdentityRegistry.sol:IdentityRegistry \
    --chain-id 43113 \
    --etherscan-api-key FUJI \
    --watch
```

**Verify ReputationRegistry:**

```bash
forge verify-contract \
    $REPUTATION_REGISTRY \
    src/ReputationRegistry.sol:ReputationRegistry \
    --chain-id 43113 \
    --constructor-args $(cast abi-encode "constructor(address)" $IDENTITY_REGISTRY) \
    --etherscan-api-key FUJI \
    --watch
```

**Check Verification:**

Visit https://testnet.snowtrace.io/address/$REPUTATION_REGISTRY

You should see ✅ "Contract Source Code Verified"

---

## Agent Integration

### Python Agent Implementation

**Complete Agent Class:**

```python
# agent.py
from web3 import Web3
from eth_account import Account
import json
import os
from dotenv import load_dotenv

load_dotenv()

class BidirectionalAgent:
    def __init__(self, private_key, domain, agent_type="server"):
        """
        Initialize agent with bidirectional trust capabilities

        Args:
            private_key (str): Agent's private key (0x...)
            domain (str): Agent's domain (e.g., "agent.example.com")
            agent_type (str): "server", "client", or "validator"
        """
        # Web3 setup
        self.w3 = Web3(Web3.HTTPProvider(os.getenv('RPC_URL_FUJI')))
        self.account = Account.from_key(private_key)
        self.domain = domain
        self.agent_type = agent_type

        # Contract setup
        self.identity_registry = self._load_contract(
            os.getenv('IDENTITY_REGISTRY'),
            'IdentityRegistry'
        )
        self.reputation_registry = self._load_contract(
            os.getenv('REPUTATION_REGISTRY'),
            'ReputationRegistry'
        )

        # Register agent (if not already registered)
        self.agent_id = self._register_agent()

        print(f"✅ Agent initialized: {self.domain}")
        print(f"   Address: {self.account.address}")
        print(f"   Agent ID: {self.agent_id}")

    def _load_contract(self, address, name):
        """Load contract ABI and create contract instance"""
        abi_path = f"contracts/out/{name}.sol/{name}.json"
        with open(abi_path) as f:
            artifact = json.load(f)

        return self.w3.eth.contract(
            address=Web3.to_checksum_address(address),
            abi=artifact['abi']
        )

    def _register_agent(self):
        """Register agent in IdentityRegistry (if not already registered)"""
        try:
            # Check if already registered
            agent_info = self.identity_registry.functions.resolveByAddress(
                self.account.address
            ).call()

            if agent_info[0] > 0:  # agentId > 0 means registered
                print(f"   Already registered with ID: {agent_info[0]}")
                return agent_info[0]
        except Exception:
            pass  # Not registered yet

        # Register new agent
        print(f"   Registering agent...")
        metadata = json.dumps({
            "type": self.agent_type,
            "domain": self.domain,
            "version": "1.0.0"
        })

        tx = self.identity_registry.functions.newAgent(
            self.account.address,
            self.domain,
            metadata
        ).build_transaction({
            'from': self.account.address,
            'gas': 200000,
            'gasPrice': self.w3.eth.gas_price,
            'nonce': self.w3.eth.get_transaction_count(self.account.address)
        })

        signed_tx = self.account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)

        # Get agent ID from registration
        agent_info = self.identity_registry.functions.resolveByAddress(
            self.account.address
        ).call()

        print(f"   ✅ Registered! Tx: {tx_hash.hex()}")
        return agent_info[0]

    def rate_client(self, client_id, rating):
        """
        Rate a client (as a server)

        Args:
            client_id (int): Client's agent ID
            rating (int): Rating 0-100 (0=poor, 100=excellent)

        Returns:
            str: Transaction hash
        """
        if not 0 <= rating <= 100:
            raise ValueError("Rating must be 0-100")

        print(f"📝 Rating client {client_id}: {rating}/100")

        tx = self.reputation_registry.functions.rateClient(
            client_id,
            rating
        ).build_transaction({
            'from': self.account.address,
            'gas': 100000,
            'gasPrice': self.w3.eth.gas_price,
            'nonce': self.w3.eth.get_transaction_count(self.account.address)
        })

        signed_tx = self.account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)

        print(f"   ✅ Client rated! Tx: {tx_hash.hex()}")
        print(f"   Gas used: {receipt['gasUsed']}")

        return tx_hash.hex()

    def rate_validator(self, validator_id, rating):
        """
        Rate a validator (as a server)

        Args:
            validator_id (int): Validator's agent ID
            rating (int): Rating 0-100

        Returns:
            str: Transaction hash
        """
        if not 0 <= rating <= 100:
            raise ValueError("Rating must be 0-100")

        print(f"📝 Rating validator {validator_id}: {rating}/100")

        tx = self.reputation_registry.functions.rateValidator(
            validator_id,
            rating
        ).build_transaction({
            'from': self.account.address,
            'gas': 100000,
            'gasPrice': self.w3.eth.gas_price,
            'nonce': self.w3.eth.get_transaction_count(self.account.address)
        })

        signed_tx = self.account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)

        print(f"   ✅ Validator rated! Tx: {tx_hash.hex()}")
        print(f"   Gas used: {receipt['gasUsed']}")

        return tx_hash.hex()

    def get_client_reputation(self, client_id):
        """
        Check client's reputation (from this server's perspective)

        Args:
            client_id (int): Client's agent ID

        Returns:
            tuple: (has_rating, rating)
        """
        has_rating, rating = self.reputation_registry.functions.getClientRating(
            client_id,
            self.agent_id
        ).call()

        if has_rating:
            print(f"🔍 Client {client_id} reputation: {rating}/100")
        else:
            print(f"🔍 Client {client_id}: No prior rating")

        return has_rating, rating

    def should_serve_client(self, client_id, min_rating=70):
        """
        Decide whether to serve a client based on reputation

        Args:
            client_id (int): Client's agent ID
            min_rating (int): Minimum acceptable rating (default 70)

        Returns:
            bool: True if should serve, False otherwise
        """
        has_rating, rating = self.get_client_reputation(client_id)

        if not has_rating:
            # No prior history - decide based on risk tolerance
            print(f"   ⚠️  New client (no history). Serving with caution.")
            return True  # Trust on first transaction

        if rating >= min_rating:
            print(f"   ✅ Client has good reputation ({rating}/100). Serving.")
            return True
        else:
            print(f"   ❌ Client has poor reputation ({rating}/100). Declining.")
            return False

    def get_validator_reputation(self, validator_id):
        """
        Check validator's reputation (from this server's perspective)

        Args:
            validator_id (int): Validator's agent ID

        Returns:
            tuple: (has_rating, rating)
        """
        has_rating, rating = self.reputation_registry.functions.getValidatorRating(
            validator_id,
            self.agent_id
        ).call()

        if has_rating:
            print(f"🔍 Validator {validator_id} reputation: {rating}/100")
        else:
            print(f"🔍 Validator {validator_id}: No prior rating")

        return has_rating, rating


# Example usage
if __name__ == "__main__":
    # Initialize server agent
    server = BidirectionalAgent(
        private_key=os.getenv('PRIVATE_KEY'),
        domain="server.example.com",
        agent_type="server"
    )

    # Initialize client agent (separate wallet)
    client = BidirectionalAgent(
        private_key=os.getenv('CLIENT_PRIVATE_KEY'),
        domain="client.example.com",
        agent_type="client"
    )

    # Simulate transaction
    print("\n--- Simulating Transaction ---")

    # Server checks client reputation before serving
    if server.should_serve_client(client.agent_id):
        print("Providing service to client...")
        # ... actual service provision logic ...

        # After service, server rates client
        server.rate_client(client.agent_id, 95)  # Excellent client
```

---

### JavaScript/TypeScript Integration

**Using ethers.js:**

```javascript
// agent.ts
import { ethers } from 'ethers';
import dotenv from 'dotenv';
import IdentityRegistryABI from './abi/IdentityRegistry.json';
import ReputationRegistryABI from './abi/ReputationRegistry.json';

dotenv.config();

class BidirectionalAgent {
    private wallet: ethers.Wallet;
    private identityRegistry: ethers.Contract;
    private reputationRegistry: ethers.Contract;
    public agentId: number;
    public domain: string;

    constructor(privateKey: string, domain: string) {
        // Connect to Avalanche Fuji
        const provider = new ethers.JsonRpcProvider(process.env.RPC_URL_FUJI);
        this.wallet = new ethers.Wallet(privateKey, provider);
        this.domain = domain;

        // Load contracts
        this.identityRegistry = new ethers.Contract(
            process.env.IDENTITY_REGISTRY!,
            IdentityRegistryABI.abi,
            this.wallet
        );

        this.reputationRegistry = new ethers.Contract(
            process.env.REPUTATION_REGISTRY!,
            ReputationRegistryABI.abi,
            this.wallet
        );
    }

    async initialize(): Promise<void> {
        this.agentId = await this.registerAgent();
        console.log(`✅ Agent initialized: ${this.domain}`);
        console.log(`   Address: ${this.wallet.address}`);
        console.log(`   Agent ID: ${this.agentId}`);
    }

    private async registerAgent(): Promise<number> {
        try {
            // Check if already registered
            const agentInfo = await this.identityRegistry.resolveByAddress(
                this.wallet.address
            );

            if (agentInfo.agentId > 0) {
                console.log(`   Already registered with ID: ${agentInfo.agentId}`);
                return agentInfo.agentId;
            }
        } catch (error) {
            // Not registered yet
        }

        // Register new agent
        console.log(`   Registering agent...`);
        const metadata = JSON.stringify({
            domain: this.domain,
            version: "1.0.0"
        });

        const tx = await this.identityRegistry.newAgent(
            this.wallet.address,
            this.domain,
            metadata
        );

        const receipt = await tx.wait();
        console.log(`   ✅ Registered! Tx: ${receipt.hash}`);

        // Get agent ID
        const agentInfo = await this.identityRegistry.resolveByAddress(
            this.wallet.address
        );

        return agentInfo.agentId;
    }

    async rateClient(clientId: number, rating: number): Promise<string> {
        if (rating < 0 || rating > 100) {
            throw new Error('Rating must be 0-100');
        }

        console.log(`📝 Rating client ${clientId}: ${rating}/100`);

        const tx = await this.reputationRegistry.rateClient(clientId, rating);
        const receipt = await tx.wait();

        console.log(`   ✅ Client rated! Tx: ${receipt.hash}`);
        console.log(`   Gas used: ${receipt.gasUsed.toString()}`);

        return receipt.hash;
    }

    async rateValidator(validatorId: number, rating: number): Promise<string> {
        if (rating < 0 || rating > 100) {
            throw new Error('Rating must be 0-100');
        }

        console.log(`📝 Rating validator ${validatorId}: ${rating}/100`);

        const tx = await this.reputationRegistry.rateValidator(validatorId, rating);
        const receipt = await tx.wait();

        console.log(`   ✅ Validator rated! Tx: ${receipt.hash}`);
        return receipt.hash;
    }

    async getClientReputation(clientId: number): Promise<[boolean, number]> {
        const [hasRating, rating] = await this.reputationRegistry.getClientRating(
            clientId,
            this.agentId
        );

        if (hasRating) {
            console.log(`🔍 Client ${clientId} reputation: ${rating}/100`);
        } else {
            console.log(`🔍 Client ${clientId}: No prior rating`);
        }

        return [hasRating, rating];
    }

    async shouldServeClient(clientId: number, minRating: number = 70): Promise<boolean> {
        const [hasRating, rating] = await this.getClientReputation(clientId);

        if (!hasRating) {
            console.log(`   ⚠️  New client (no history). Serving with caution.`);
            return true;
        }

        if (rating >= minRating) {
            console.log(`   ✅ Client has good reputation (${rating}/100). Serving.`);
            return true;
        } else {
            console.log(`   ❌ Client has poor reputation (${rating}/100). Declining.`);
            return false;
        }
    }
}

// Example usage
async function main() {
    const server = new BidirectionalAgent(
        process.env.PRIVATE_KEY!,
        'server.example.com'
    );
    await server.initialize();

    const client = new BidirectionalAgent(
        process.env.CLIENT_PRIVATE_KEY!,
        'client.example.com'
    );
    await client.initialize();

    // Check client reputation
    if (await server.shouldServeClient(client.agentId)) {
        console.log('Providing service...');
        // ... service logic ...

        // Rate client after service
        await server.rateClient(client.agentId, 95);
    }
}

main().catch(console.error);
```

---

## Common Pitfalls & Solutions

### Pitfall 1: Gas Estimation Failures

**Problem:** Transaction fails with "gas estimation failed"

**Cause:** Contract reverts before execution (e.g., agent not registered)

**Solution:**

```python
# Check agent exists before rating
try:
    agent_info = identity_registry.functions.getAgent(client_id).call()
    if agent_info[0] == 0:  # agentId == 0 means not found
        raise Exception(f"Agent {client_id} not registered")
except Exception as e:
    print(f"❌ Cannot rate: {e}")
    return

# Now safe to rate
reputation_registry.functions.rateClient(client_id, rating).transact()
```

---

### Pitfall 2: Nonce Management

**Problem:** Transaction fails with "nonce too low" or "nonce too high"

**Cause:** Multiple concurrent transactions from same address

**Solution:**

```python
# Track nonce manually for concurrent transactions
class NonceManager:
    def __init__(self, w3, account):
        self.w3 = w3
        self.account = account
        self.nonce = w3.eth.get_transaction_count(account.address)

    def get_nonce(self):
        nonce = self.nonce
        self.nonce += 1
        return nonce

    def reset(self):
        self.nonce = self.w3.eth.get_transaction_count(self.account.address)

# Usage
nonce_mgr = NonceManager(w3, account)

for client_id in clients_to_rate:
    tx = contract.functions.rateClient(client_id, 90).build_transaction({
        'from': account.address,
        'nonce': nonce_mgr.get_nonce(),  # Incremental nonces
        'gas': 100000,
        'gasPrice': w3.eth.gas_price
    })

    signed_tx = account.sign_transaction(tx)
    tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
    # Don't wait here (parallel sending)

# Wait for all confirmations
for tx_hash in tx_hashes:
    w3.eth.wait_for_transaction_receipt(tx_hash)
```

---

### Pitfall 3: Self-Rating Not Prevented (V1)

**Problem:** Agent accidentally rates itself

**Code:**
```python
# This will succeed but is meaningless
server.rate_client(server.agent_id, 100)  # Self-rating!
```

**Solution:** Add client-side check

```python
def rate_client(self, client_id, rating):
    # Prevent self-rating
    if client_id == self.agent_id:
        raise ValueError("Cannot rate yourself as a client")

    # Proceed with rating
    tx = self.reputation_registry.functions.rateClient(client_id, rating).transact()
```

**Note:** V2 will prevent this on-chain with `CannotRateSelf()` error.

---

### Pitfall 4: Transaction Confirmation Waiting

**Problem:** Script hangs waiting for transaction receipt

**Cause:** Network congestion or low gas price

**Solution:**

```python
import time

def wait_for_receipt_with_timeout(w3, tx_hash, timeout=60):
    """Wait for receipt with timeout"""
    start_time = time.time()

    while time.time() - start_time < timeout:
        try:
            receipt = w3.eth.get_transaction_receipt(tx_hash)
            if receipt:
                return receipt
        except Exception:
            pass

        time.sleep(2)  # Poll every 2 seconds

    raise TimeoutError(f"Transaction {tx_hash.hex()} not confirmed after {timeout}s")

# Usage
tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
receipt = wait_for_receipt_with_timeout(w3, tx_hash, timeout=120)
```

---

### Pitfall 5: Rating Scale Confusion

**Problem:** Agent rates with 1-5 stars instead of 0-100

**Code:**
```python
# WRONG: Using star scale
server.rate_client(client_id, 5)  # Means 5/100 (terrible!)

# CORRECT: Using 0-100 scale
server.rate_client(client_id, 100)  # Means 100/100 (excellent)
```

**Solution:** Document clearly and add validation

```python
def rate_client(self, client_id, rating):
    """
    Rate a client on 0-100 scale

    Rating Guide:
    - 0-30: Poor (payment issues, dishonest)
    - 31-60: Below average (some problems)
    - 61-80: Good (reliable, minor issues)
    - 81-100: Excellent (perfect client)
    """
    if not 0 <= rating <= 100:
        raise ValueError(f"Rating must be 0-100, got {rating}")

    # Sanity check (prevent star confusion)
    if rating <= 5:
        print(f"⚠️  WARNING: Rating {rating} is very low. Did you mean {rating * 20}?")
        confirm = input("Continue? (y/n): ")
        if confirm.lower() != 'y':
            return

    # Proceed with rating
    tx = self.reputation_registry.functions.rateClient(client_id, rating).transact()
```

---

## Testing Strategies

### Unit Tests (Foundry)

**Test File:** `contracts/test/ReputationRegistry.t.sol`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/ReputationRegistry.sol";
import "../src/IdentityRegistry.sol";

contract ReputationRegistryTest is Test {
    IdentityRegistry identityRegistry;
    ReputationRegistry reputationRegistry;

    address server = address(0x1);
    address client = address(0x2);
    address validator = address(0x3);

    function setUp() public {
        // Deploy contracts
        identityRegistry = new IdentityRegistry();
        reputationRegistry = new ReputationRegistry(address(identityRegistry));

        // Register agents
        vm.prank(server);
        identityRegistry.newAgent(server, "server.test", "{}");

        vm.prank(client);
        identityRegistry.newAgent(client, "client.test", "{}");

        vm.prank(validator);
        identityRegistry.newAgent(validator, "validator.test", "{}");
    }

    function testRateClient() public {
        // Server rates client
        vm.prank(server);
        reputationRegistry.rateClient(2, 95);  // Client agentId = 2

        // Query rating
        (bool hasRating, uint8 rating) = reputationRegistry.getClientRating(2, 1);

        assertTrue(hasRating, "Rating should exist");
        assertEq(rating, 95, "Rating should be 95");
    }

    function testRateValidator() public {
        // Server rates validator
        vm.prank(server);
        reputationRegistry.rateValidator(3, 88);  // Validator agentId = 3

        // Query rating
        (bool hasRating, uint8 rating) = reputationRegistry.getValidatorRating(3, 1);

        assertTrue(hasRating);
        assertEq(rating, 88);
    }

    function testCannotRateNonExistentAgent() public {
        vm.prank(server);
        vm.expectRevert(IReputationRegistry.AgentNotFound.selector);
        reputationRegistry.rateClient(999, 50);  // Non-existent agent
    }

    function testInvalidRating() public {
        vm.prank(server);
        vm.expectRevert();
        reputationRegistry.rateClient(2, 101);  // Rating > 100
    }
}
```

**Run Tests:**
```bash
cd contracts
forge test -vv
```

**Expected Output:**
```
Running 4 tests for test/ReputationRegistry.t.sol:ReputationRegistryTest
[PASS] testRateClient() (gas: 98234)
[PASS] testRateValidator() (gas: 97891)
[PASS] testCannotRateNonExistentAgent() (gas: 45123)
[PASS] testInvalidRating() (gas: 43567)
Test result: ok. 4 passed; 0 failed; finished in 2.34ms
```

---

### Integration Tests (Python)

**Test File:** `tests/test_bidirectional_flow.py`

```python
import pytest
from agent import BidirectionalAgent
import os

@pytest.fixture
def server_agent():
    return BidirectionalAgent(
        private_key=os.getenv('TEST_SERVER_KEY'),
        domain="test-server.example.com"
    )

@pytest.fixture
def client_agent():
    return BidirectionalAgent(
        private_key=os.getenv('TEST_CLIENT_KEY'),
        domain="test-client.example.com"
    )

def test_full_transaction_flow(server_agent, client_agent):
    """Test complete transaction with bidirectional rating"""

    # Step 1: Server checks client reputation (new client, no history)
    has_rating, rating = server_agent.get_client_reputation(client_agent.agent_id)
    assert not has_rating, "New client should have no rating"

    # Step 2: Server decides to serve (trust on first transaction)
    should_serve = server_agent.should_serve_client(client_agent.agent_id)
    assert should_serve, "Should serve new clients"

    # Step 3: Transaction completes (simulated)
    # ... service provision logic ...

    # Step 4: Server rates client (excellent experience)
    tx_hash = server_agent.rate_client(client_agent.agent_id, 95)
    assert tx_hash, "Rating transaction should succeed"

    # Step 5: Verify rating stored on-chain
    has_rating, rating = server_agent.get_client_reputation(client_agent.agent_id)
    assert has_rating, "Rating should now exist"
    assert rating == 95, "Rating should be 95"

def test_reject_low_rated_client(server_agent, client_agent):
    """Test that server rejects clients with poor reputation"""

    # Rate client poorly
    server_agent.rate_client(client_agent.agent_id, 30)

    # Server should reject this client on next transaction
    should_serve = server_agent.should_serve_client(client_agent.agent_id, min_rating=70)
    assert not should_serve, "Should reject client with rating < 70"

def test_validator_rating(server_agent):
    """Test validator rating flow"""
    # Create validator agent
    validator = BidirectionalAgent(
        private_key=os.getenv('TEST_VALIDATOR_KEY'),
        domain="test-validator.example.com",
        agent_type="validator"
    )

    # Server rates validator
    tx_hash = server_agent.rate_validator(validator.agent_id, 92)
    assert tx_hash, "Validator rating should succeed"

    # Verify rating
    has_rating, rating = server_agent.get_validator_reputation(validator.agent_id)
    assert has_rating
    assert rating == 92
```

**Run Integration Tests:**
```bash
pytest tests/test_bidirectional_flow.py -v
```

---

### Testnet Deployment Checklist

**Before deploying to testnet:**

- [ ] All unit tests passing (forge test)
- [ ] All integration tests passing (pytest)
- [ ] Contracts verified on Snowtrace
- [ ] Test transactions executed successfully
- [ ] Gas costs measured (Week 2: ~21,557 gas per rating)
- [ ] Error cases tested (non-existent agents, invalid ratings)
- [ ] Documentation reviewed
- [ ] .env file properly configured (no private keys committed)

**Deployment Steps:**

1. ✅ Deploy IdentityRegistry
2. ✅ Deploy ReputationRegistry (with IdentityRegistry address)
3. ✅ Verify contracts on Snowtrace
4. ✅ Register test agents (2-3 agents)
5. ✅ Execute test ratings (rate_client, rate_validator)
6. ✅ Query ratings (verify storage)
7. ✅ Monitor gas costs
8. ✅ Check events emitted (ClientRated, ValidatorRated)

---

## Complete Example: End-to-End Workflow

**Scenario:** karma-hello (server) interacts with abracadabra (client)

```python
#!/usr/bin/env python3
# example_workflow.py

from agent import BidirectionalAgent
import os

def main():
    print("=== EIP-8004 Bidirectional Trust Demo ===\n")

    # Initialize agents
    print("Step 1: Initialize agents")
    karma_hello = BidirectionalAgent(
        private_key=os.getenv('KARMA_HELLO_KEY'),
        domain="karma-hello.karmacadabra.ultravioletadao.xyz",
        agent_type="server"
    )

    abracadabra = BidirectionalAgent(
        private_key=os.getenv('ABRACADABRA_KEY'),
        domain="abracadabra.karmacadabra.ultravioletadao.xyz",
        agent_type="client"
    )

    print("\nStep 2: abracadabra requests chat logs from karma-hello")

    # karma-hello checks abracadabra's reputation
    print("\nStep 3: karma-hello checks client reputation")
    if not karma_hello.should_serve_client(abracadabra.agent_id):
        print("❌ Service declined due to poor client reputation")
        return

    # Provide service (simulated)
    print("\nStep 4: karma-hello provides chat logs")
    print("   Delivering logs...")
    # ... actual service logic ...
    print("   ✅ Logs delivered successfully")

    # Rate client
    print("\nStep 5: karma-hello rates abracadabra as client")
    karma_hello.rate_client(abracadabra.agent_id, 95)

    print("\n=== Transaction Complete ===")
    print(f"abracadabra's reputation (from karma-hello): 95/100")

if __name__ == "__main__":
    main()
```

**Run:**
```bash
python example_workflow.py
```

**Expected Output:**
```
=== EIP-8004 Bidirectional Trust Demo ===

Step 1: Initialize agents
✅ Agent initialized: karma-hello.karmacadabra.ultravioletadao.xyz
   Address: 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb6
   Agent ID: 1

✅ Agent initialized: abracadabra.karmacadabra.ultravioletadao.xyz
   Address: 0x9a3c12Bb8f4e5d6789a0b1c2d3e4f567890abcde
   Agent ID: 2

Step 2: abracadabra requests chat logs from karma-hello

Step 3: karma-hello checks client reputation
🔍 Client 2: No prior rating
   ⚠️  New client (no history). Serving with caution.

Step 4: karma-hello provides chat logs
   Delivering logs...
   ✅ Logs delivered successfully

Step 5: karma-hello rates abracadabra as client
📝 Rating client 2: 95/100
   ✅ Client rated! Tx: 0xabcd1234...
   Gas used: 21557

=== Transaction Complete ===
abracadabra's reputation (from karma-hello): 95/100
```

---

## Next Steps

**You've now learned:**
- ✅ How to deploy contracts
- ✅ How to register agents
- ✅ How to rate clients and validators
- ✅ How to query reputation
- ✅ How to test the system

**Further Reading:**
- **Day 4:** API Reference (complete method documentation)
- **Week 2:** Real-world data (99 transactions on Fuji)
- **Week 3:** Security analysis (threat modeling, attack simulations)
- **Week 4:** Comparative analysis (vs Uber/Airbnb/eBay)

**Production Deployment:**
- Mainnet deployment (use production RPC, real AVAX)
- Monitoring setup (track ratings, gas costs)
- Indexer integration (The Graph for aggregated queries)
- UI development (display reputation in agent marketplace)

---

**Status:** ✅ DAY 3 COMPLETE
**Time:** 4 hours
**Output:** Complete implementation guide with Python + JavaScript examples, common pitfalls, testing strategies, and end-to-end workflow
**Next:** Day 4 - API reference documentation
