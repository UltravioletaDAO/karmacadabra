# EIP-8004 Bidirectional Trust - API Reference

**Week 5 Day 4:** Complete API Reference
**Date:** November 2, 2025
**Version:** 1.0.0

---

## Overview

This document provides a complete reference for all EIP-8004 bidirectional trust methods. Use this as a quick lookup when integrating the contracts into your agent system.

**Contract Addresses (Avalanche Fuji Testnet):**
- IdentityRegistry: `0x63Be8347017fFF5a2FBA4f82e8f5E5a60C53c8d1`
- ReputationRegistry: `0x63B9ddbc69a6b1b62827c52a1b796a47fcE24f2b`

**Quick Navigation:**
- [Writing Methods](#writing-methods) - Modify on-chain state
- [Query Methods](#query-methods) - Read reputation data
- [Base EIP-8004 Methods](#base-eip-8004-methods) - Unchanged from base spec
- [Events](#events) - On-chain event emissions
- [Error Cases](#error-cases) - Revert conditions
- [Quick Reference Table](#quick-reference-table) - All methods at-a-glance

---

## Writing Methods

### rateClient()

Rate a client's quality after they've consumed your service.

#### Signature

```solidity
function rateClient(uint256 agentClientId, uint8 rating) external
```

#### Parameters

| Name | Type | Description |
|------|------|-------------|
| `agentClientId` | uint256 | The agent ID of the client being rated |
| `rating` | uint8 | Quality score from 0 to 100 |

#### Rating Scale Guide

| Range | Quality | When to Use |
|-------|---------|-------------|
| 0-30 | Poor | Payment issues, dishonest behavior, communication problems |
| 31-60 | Below Average | Some issues, proceed with caution |
| 61-80 | Good | Reliable, minor issues only |
| 81-100 | Excellent | Prompt, clear, honest - ideal client |

#### Returns

None (state-changing transaction)

#### Events Emitted

```solidity
event ClientRated(
    uint256 indexed clientId,
    uint256 indexed serverId,
    uint8 rating
)
```

#### Gas Cost

- **Average:** 21,557 gas (measured on Avalanche Fuji)
- **Max:** ~30,000 gas (first-time storage slot)
- **USD Cost:** ~$0.016 on Fuji (at 25 gwei, AVAX=$30)

#### Requirements

- ✅ Caller must be a registered agent
- ✅ `agentClientId` must exist in IdentityRegistry
- ✅ `rating` must be ≤ 100

#### Error Cases

| Error | Condition | Solidity Selector |
|-------|-----------|-------------------|
| `AgentNotFound` | Client ID doesn't exist | `0x38e8f3aa` |
| `AgentNotFound` | Caller not registered | `0x38e8f3aa` |
| `UnauthorizedFeedback` | Rating > 100 | `0x8baa579f` |

#### Example (Solidity)

```solidity
contract MyServer {
    ReputationRegistry public registry;

    function rateClientAfterService(uint256 clientId) external {
        // Rate based on service quality
        registry.rateClient(clientId, 95);
    }
}
```

#### Example (Python/web3.py)

```python
from web3 import Web3
from eth_account import Account

# Setup
w3 = Web3(Web3.HTTPProvider(RPC_URL))
registry = w3.eth.contract(address=REPUTATION_REGISTRY, abi=ABI)
account = Account.from_key(PRIVATE_KEY)

# Rate client
tx = registry.functions.rateClient(
    client_id,  # uint256
    95          # uint8 (0-100)
).build_transaction({
    'from': account.address,
    'gas': 100000,
    'gasPrice': w3.eth.gas_price,
    'nonce': w3.eth.get_transaction_count(account.address)
})

signed_tx = account.sign_transaction(tx)
tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

print(f"Client rated! Tx: {tx_hash.hex()}")
print(f"Gas used: {receipt['gasUsed']}")
```

#### Example (JavaScript/ethers.js)

```javascript
import { ethers } from 'ethers';

// Setup
const provider = new ethers.JsonRpcProvider(RPC_URL);
const wallet = new ethers.Wallet(PRIVATE_KEY, provider);
const registry = new ethers.Contract(REPUTATION_REGISTRY, ABI, wallet);

// Rate client
const tx = await registry.rateClient(clientId, 95);
const receipt = await tx.wait();

console.log(`Client rated! Tx: ${receipt.hash}`);
console.log(`Gas used: ${receipt.gasUsed.toString()}`);
```

#### Best Practices

✅ **Do:**
- Rate promptly after transaction completes
- Use full 0-100 scale (not just 0/50/100)
- Consider multiple factors (payment, communication, honesty)
- Document rating rationale in off-chain metadata

❌ **Don't:**
- Rate yourself (self-rating is meaningless)
- Rate based on emotions (use objective criteria)
- Give all 100s (loses informational value)
- Rate before transaction completes

---

### rateValidator()

Rate a validator's quality after they've audited a transaction.

#### Signature

```solidity
function rateValidator(uint256 agentValidatorId, uint8 rating) external
```

#### Parameters

| Name | Type | Description |
|------|------|-------------|
| `agentValidatorId` | uint256 | The agent ID of the validator being rated |
| `rating` | uint8 | Quality score from 0 to 100 |

#### Rating Scale Guide (Validator-Specific)

| Range | Quality | When to Use |
|-------|---------|-------------|
| 0-30 | Poor | Biased assessments, inaccurate judgments, unfair |
| 31-60 | Below Average | Some accuracy issues, questionable fairness |
| 61-80 | Good | Fair, mostly accurate, occasional inconsistency |
| 81-100 | Excellent | Unbiased, accurate, consistent, timely |

#### Returns

None (state-changing transaction)

#### Events Emitted

```solidity
event ValidatorRated(
    uint256 indexed validatorId,
    uint256 indexed serverId,
    uint8 rating
)
```

#### Gas Cost

- **Average:** 21,557 gas (same as rateClient)
- **Max:** ~30,000 gas

#### Requirements

- ✅ Caller must be a registered agent
- ✅ `agentValidatorId` must exist in IdentityRegistry
- ✅ `rating` must be ≤ 100

#### Error Cases

Same as `rateClient()` (see above)

#### Example (Solidity)

```solidity
contract MyServer {
    ReputationRegistry public registry;

    function rateValidatorAfterAudit(uint256 validatorId, uint8 validatorScore) external {
        // Validator assessed transaction quality
        // Now rate the validator's accuracy
        registry.rateValidator(validatorId, validatorScore);
    }
}
```

#### Example (Python/web3.py)

```python
# Rate validator
tx = registry.functions.rateValidator(
    validator_id,  # uint256
    88             # uint8 (good but room for improvement)
).build_transaction({
    'from': account.address,
    'gas': 100000,
    'gasPrice': w3.eth.gas_price,
    'nonce': w3.eth.get_transaction_count(account.address)
})

signed_tx = account.sign_transaction(tx)
tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
```

#### Example (JavaScript/ethers.js)

```javascript
// Rate validator
const tx = await registry.rateValidator(validatorId, 88);
const receipt = await tx.wait();
console.log(`Validator rated! Gas: ${receipt.gasUsed}`);
```

#### Best Practices

✅ **Do:**
- Compare validator's assessment to actual quality
- Rate based on accuracy and fairness
- Consider multiple validations (don't judge on single case)
- Track validator consistency over time

❌ **Don't:**
- Rate poorly just because validator found issues (accuracy matters, not favorability)
- Rate 100 if validator made any errors
- Use validator ratings as retaliation

---

## Query Methods

### getClientRating()

Query the rating you gave to a specific client.

#### Signature

```solidity
function getClientRating(
    uint256 agentClientId,
    uint256 agentServerId
) external view returns (bool hasRating, uint8 rating)
```

#### Parameters

| Name | Type | Description |
|------|------|-------------|
| `agentClientId` | uint256 | Client being queried |
| `agentServerId` | uint256 | Server who gave the rating (usually you) |

#### Returns

| Name | Type | Description |
|------|------|-------------|
| `hasRating` | bool | True if this server rated this client, false otherwise |
| `rating` | uint8 | The rating value (0-100), only valid if hasRating is true |

#### Gas Cost

- **Average:** ~3,000 gas (read-only, no state change)
- **Free:** If called via `.call()` (doesn't create transaction)

#### Usage Pattern

```solidity
// Check before serving
(bool hasRating, uint8 rating) = registry.getClientRating(clientId, myServerId);

if (hasRating && rating < 70) {
    revert("Client has poor reputation, declining service");
}

// Client has good reputation or no history, proceed
```

#### Example (Python/web3.py)

```python
# Query client reputation (no transaction, free call)
has_rating, rating = registry.functions.getClientRating(
    client_id,
    my_server_id
).call()

if has_rating:
    print(f"Client reputation: {rating}/100")
    if rating >= 70:
        print("✅ Good reputation, serving")
    else:
        print("❌ Poor reputation, declining")
else:
    print("⚠️  New client (no prior rating)")
    print("   Serving with caution (trust on first transaction)")
```

#### Example (JavaScript/ethers.js)

```javascript
// Query (read-only, no gas cost)
const [hasRating, rating] = await registry.getClientRating(clientId, myServerId);

if (hasRating) {
    console.log(`Client reputation: ${rating}/100`);
    if (rating >= 70) {
        console.log('✅ Good reputation');
    } else {
        console.log('❌ Poor reputation, declining');
    }
} else {
    console.log('⚠️  New client (no history)');
}
```

#### Interpretation Guide

| hasRating | rating | Interpretation | Action |
|-----------|--------|----------------|--------|
| `false` | N/A | No prior history with this client | Serve (trust on first) OR require deposit |
| `true` | 0-30 | Poor reputation | **Decline** service |
| `true` | 31-60 | Below average | Serve with caution (require deposit) |
| `true` | 61-80 | Good reputation | Serve normally |
| `true` | 81-100 | Excellent reputation | Serve, offer premium features |

#### Notes

- This returns **your specific rating** of the client (not average from all servers)
- For aggregated reputation, query multiple servers off-chain
- Use The Graph or similar indexer for global reputation views

---

### getValidatorRating()

Query the rating you gave to a specific validator.

#### Signature

```solidity
function getValidatorRating(
    uint256 agentValidatorId,
    uint256 agentServerId
) external view returns (bool hasRating, uint8 rating)
```

#### Parameters

| Name | Type | Description |
|------|------|-------------|
| `agentValidatorId` | uint256 | Validator being queried |
| `agentServerId` | uint256 | Server who gave the rating (usually you) |

#### Returns

| Name | Type | Description |
|------|------|-------------|
| `hasRating` | bool | True if rating exists |
| `rating` | uint8 | The rating value (0-100) |

#### Gas Cost

- **Average:** ~3,000 gas (read-only)
- **Free:** If called via `.call()`

#### Usage Pattern

```solidity
// Before hiring validator
(bool hasRating, uint8 rating) = registry.getValidatorRating(validatorId, myServerId);

if (hasRating && rating < 80) {
    // This validator was inaccurate/unfair before
    // Consider using different validator
    selectAlternativeValidator();
}
```

#### Example (Python/web3.py)

```python
# Query validator reputation
has_rating, rating = registry.functions.getValidatorRating(
    validator_id,
    my_server_id
).call()

if has_rating:
    print(f"Validator reputation: {rating}/100")
    if rating >= 80:
        print("✅ Excellent validator, hiring")
    else:
        print("⚠️  Below standard, considering alternatives")
else:
    print("New validator (no history)")
```

#### Example (JavaScript/ethers.js)

```javascript
const [hasRating, rating] = await registry.getValidatorRating(validatorId, myServerId);

if (hasRating && rating >= 80) {
    console.log('✅ Hiring validator (good track record)');
} else if (hasRating) {
    console.log(`⚠️  Validator rated ${rating}/100, looking for alternatives`);
} else {
    console.log('New validator (no history)');
}
```

---

## Base EIP-8004 Methods (Unchanged)

These methods are inherited from base EIP-8004 specification and remain **unchanged** in the bidirectional extension.

### acceptFeedback()

Authorize feedback collection for a client-server pair.

#### Signature

```solidity
function acceptFeedback(
    uint256 agentClientId,
    uint256 agentServerId
) external
```

#### Purpose

In base EIP-8004, this authorizes the client to leave feedback about the server. The bidirectional extension **adds** rating methods but keeps this authorization mechanism.

#### When to Use

- Use when you want to authorize client feedback (base pattern)
- NOT required for bidirectional ratings (rateClient/rateValidator work independently)

#### Gas Cost

~40,000 gas (more expensive than rating, stores authorization hash)

#### Example

```python
# Authorize client to leave feedback (base EIP-8004)
tx = registry.functions.acceptFeedback(client_id, server_id).transact()
```

**Note:** Most bidirectional implementations don't use `acceptFeedback()` (ratings are direct, not pre-authorized).

---

### isFeedbackAuthorized()

Check if feedback has been authorized for a client-server pair.

#### Signature

```solidity
function isFeedbackAuthorized(
    uint256 agentClientId,
    uint256 agentServerId
) external view returns (bool isAuthorized, bytes32 feedbackAuthId)
```

#### Returns

| Name | Type | Description |
|------|------|-------------|
| `isAuthorized` | bool | True if feedback was authorized via acceptFeedback() |
| `feedbackAuthId` | bytes32 | Unique authorization ID |

#### Example

```python
is_authorized, auth_id = registry.functions.isFeedbackAuthorized(
    client_id, server_id
).call()

if is_authorized:
    print(f"Feedback authorized: {auth_id.hex()}")
```

---

## Events

### ClientRated

Emitted when a server rates a client.

```solidity
event ClientRated(
    uint256 indexed clientId,
    uint256 indexed serverId,
    uint8 rating
)
```

#### Parameters

| Name | Indexed | Type | Description |
|------|---------|------|-------------|
| `clientId` | ✅ | uint256 | Client agent ID |
| `serverId` | ✅ | uint256 | Server agent ID (who gave rating) |
| `rating` | ❌ | uint8 | Rating value (0-100) |

#### Listening for Events (Python)

```python
# Listen for ClientRated events
def handle_client_rated(event):
    print(f"Client {event['args']['clientId']} rated {event['args']['rating']}/100")
    print(f"  by server {event['args']['serverId']}")
    print(f"  Tx: {event['transactionHash'].hex()}")

# Create filter
filter = registry.events.ClientRated.create_filter(fromBlock='latest')

# Poll for events
while True:
    for event in filter.get_new_entries():
        handle_client_rated(event)
    time.sleep(2)
```

#### Listening for Events (JavaScript)

```javascript
// Listen for ClientRated events
registry.on('ClientRated', (clientId, serverId, rating, event) => {
    console.log(`Client ${clientId} rated ${rating}/100 by server ${serverId}`);
    console.log(`Tx: ${event.transactionHash}`);
});
```

---

### ValidatorRated

Emitted when a server rates a validator.

```solidity
event ValidatorRated(
    uint256 indexed validatorId,
    uint256 indexed serverId,
    uint8 rating
)
```

#### Parameters

| Name | Indexed | Type | Description |
|------|---------|------|-------------|
| `validatorId` | ✅ | uint256 | Validator agent ID |
| `serverId` | ✅ | uint256 | Server agent ID (who gave rating) |
| `rating` | ❌ | uint8 | Rating value (0-100) |

#### Usage

Same as `ClientRated` (see above), just substitute event name:

```python
filter = registry.events.ValidatorRated.create_filter(fromBlock='latest')
```

---

## Error Cases

### AgentNotFound

**Condition:** Agent ID doesn't exist in IdentityRegistry

**Solidity:**
```solidity
error AgentNotFound();
```

**When Thrown:**
- Calling `rateClient()` with non-existent client ID
- Calling `rateValidator()` with non-existent validator ID
- Caller is not a registered agent

**Prevention:**
```python
# Check agent exists before rating
try:
    agent_info = identity_registry.functions.getAgent(client_id).call()
    if agent_info[0] == 0:  # agentId == 0 means not found
        raise Exception(f"Agent {client_id} not registered")
except Exception:
    print("Cannot rate: agent not found")
    return
```

---

### UnauthorizedFeedback

**Condition:** Rating value exceeds maximum (100)

**Solidity:**
```solidity
error UnauthorizedFeedback();
```

**When Thrown:**
- `rating > 100`

**Prevention:**
```python
def rate_client(client_id, rating):
    if not 0 <= rating <= 100:
        raise ValueError(f"Rating must be 0-100, got {rating}")

    # Proceed with on-chain call
    tx = registry.functions.rateClient(client_id, rating).transact()
```

---

## Quick Reference Table

### All Methods At-a-Glance

| Method | Type | Gas Cost | Returns | When to Use |
|--------|------|----------|---------|-------------|
| **Bidirectional Extension** |
| `rateClient()` | Write | ~21,557 | None | After serving a client |
| `rateValidator()` | Write | ~21,557 | None | After validator audits |
| `getClientRating()` | Read | ~3,000 (free) | (bool, uint8) | Before serving client |
| `getValidatorRating()` | Read | ~3,000 (free) | (bool, uint8) | Before hiring validator |
| **Base EIP-8004** |
| `acceptFeedback()` | Write | ~40,000 | None | Authorize client feedback |
| `isFeedbackAuthorized()` | Read | ~3,000 (free) | (bool, bytes32) | Check authorization |

### Rating Scale Reference

| Value | Quality | Client Behavior | Validator Behavior |
|-------|---------|-----------------|-------------------|
| 0-30 | Poor | Payment issues, dishonest | Biased, inaccurate |
| 31-60 | Below Avg | Some problems | Questionable fairness |
| 61-80 | Good | Reliable, minor issues | Mostly accurate |
| 81-100 | Excellent | Prompt, clear, honest | Unbiased, accurate |

### Gas Cost Summary

| Operation | Gas Cost | USD (Fuji) |
|-----------|----------|------------|
| Deploy IdentityRegistry | ~1,200,000 | ~$3.20 |
| Deploy ReputationRegistry | ~1,500,000 | ~$4.00 |
| Register agent | ~120,000 | ~$0.32 |
| Rate client | ~21,557 | ~$0.016 |
| Rate validator | ~21,557 | ~$0.016 |
| Query rating | ~3,000 (free if .call()) | $0 |

*Assumes AVAX=$30, gas=25 gwei on Fuji*

---

## Code Snippets

### Common Patterns

#### Pattern 1: Check Reputation Before Serving

```python
def handle_service_request(client_id):
    """Check client reputation before providing service"""

    # Query reputation
    has_rating, rating = registry.functions.getClientRating(
        client_id, my_agent_id
    ).call()

    # Decision logic
    if not has_rating:
        # New client: trust on first transaction
        print("⚠️  New client, serving with caution")
        return provide_service(client_id)

    if rating >= 70:
        print(f"✅ Good client ({rating}/100), serving")
        return provide_service(client_id)
    else:
        print(f"❌ Poor client ({rating}/100), declining")
        raise Exception("Client reputation too low")
```

---

#### Pattern 2: Rate After Transaction

```python
def complete_transaction(client_id):
    """Provide service and rate client"""

    try:
        # Provide service
        result = provide_service(client_id)

        # Assess quality
        quality_score = assess_client_quality(client_id)
        # quality_score based on:
        #   - Payment timeliness (30 points)
        #   - Communication clarity (30 points)
        #   - Honesty (40 points)

        # Rate client
        tx = registry.functions.rateClient(
            client_id, quality_score
        ).transact()

        print(f"✅ Transaction complete, client rated {quality_score}/100")
        return result

    except Exception as e:
        # Service failed, rate poorly
        registry.functions.rateClient(client_id, 20).transact()
        raise
```

---

#### Pattern 3: Aggregate Reputation (Off-Chain)

```python
def get_aggregate_reputation(client_id, server_ids):
    """
    Get client's average reputation across multiple servers
    (Off-chain aggregation)
    """
    ratings = []

    for server_id in server_ids:
        has_rating, rating = registry.functions.getClientRating(
            client_id, server_id
        ).call()

        if has_rating:
            ratings.append(rating)

    if not ratings:
        return None, "No ratings"

    avg = sum(ratings) / len(ratings)
    return avg, f"{len(ratings)} ratings"

# Usage
avg_reputation, context = get_aggregate_reputation(client_id, all_server_ids)
print(f"Client average reputation: {avg_reputation}/100 ({context})")
```

---

#### Pattern 4: Event-Driven Reputation Updates

```python
def listen_for_ratings():
    """Listen for rating events and update local cache"""

    filter = registry.events.ClientRated.create_filter(fromBlock='latest')

    while True:
        for event in filter.get_new_entries():
            client_id = event['args']['clientId']
            server_id = event['args']['serverId']
            rating = event['args']['rating']

            # Update local cache/database
            update_reputation_cache(client_id, server_id, rating)

            print(f"Cache updated: Client {client_id} rated {rating}/100")

        time.sleep(2)  # Poll every 2 seconds
```

---

## Integration Checklist

**Before going to production:**

- [ ] Contracts deployed and verified
- [ ] Test transactions executed successfully
- [ ] Gas costs measured and acceptable
- [ ] Error handling implemented (AgentNotFound, etc.)
- [ ] Rating scale documented for your agents
- [ ] Reputation query logic tested
- [ ] Event listeners set up (if needed)
- [ ] Off-chain aggregation strategy decided
- [ ] Client-side validation added (prevent self-rating)
- [ ] Monitoring/alerting configured

---

## Support & Resources

**Documentation:**
- Week 5 Day 1-2: [Formal Specification](5.1-DAY1-SPECIFICATION-PART1.md)
- Week 5 Day 3: [Implementation Guide](5.3-DAY3-IMPLEMENTATION-GUIDE.md)

**Code Examples:**
- Repository: https://github.com/ultravioletadao/karmacadabra
- Contracts: `erc-8004/contracts/src/`
- Python integration: `shared/base_agent.py`
- Tests: `erc-8004/contracts/test/`

**Real-World Data:**
- Week 2: [99 transactions on Fuji testnet](../week2/)
- Week 3: [Security analysis](../week3/)
- Week 4: [Comparative analysis](../week4/)

**Community:**
- GitHub Issues: https://github.com/ultravioletadao/karmacadabra/issues
- Discord: [coming soon]

---

**Status:** ✅ DAY 4 COMPLETE
**Time:** 4 hours
**Output:** Complete API reference with quick lookup tables, code snippets, and integration patterns
**Next:** Day 5 - Week 5 summary, documentation index, and validation
